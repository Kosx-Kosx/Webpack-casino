import { Inject, Injectable, InjectionToken, Injector, PLATFORM_ID, NgModule, Optional, SkipSelf } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { __extends } from 'tslib';
import { EventEmitter } from 'events';

var CacheLoader = (function () {
    function CacheLoader() {
    }
    return CacheLoader;
}());
var CacheStaticLoader = (function () {
    function CacheStaticLoader(providedSettings) {
        if (providedSettings === void 0) { providedSettings = {
            key: 'NGX_CACHE',
            lifeSpan: {
                expiry: Number.MAX_VALUE,
                TTL: Number.MAX_VALUE
            }
        }; }
        this.providedSettings = providedSettings;
    }
    Object.defineProperty(CacheStaticLoader.prototype, "key", {
        get: function () {
            return this.providedSettings.key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CacheStaticLoader.prototype, "lifeSpan", {
        get: function () {
            return this.providedSettings.lifeSpan;
        },
        enumerable: true,
        configurable: true
    });
    return CacheStaticLoader;
}());

var ReturnType;
(function (ReturnType) {
    ReturnType[ReturnType["Scalar"] = 0] = "Scalar";
    ReturnType[ReturnType["Observable"] = 10] = "Observable";
    ReturnType[ReturnType["Promise"] = 20] = "Promise";
})(ReturnType || (ReturnType = {}));

var CACHE = new InjectionToken('CACHE');
var CacheService = (function () {
    function CacheService(loader, platformId, injector) {
        this.loader = loader;
        this.platformId = platformId;
        this.injector = injector;
        CacheService.instance = this;
        this.cache = this.injector.get(CACHE);
        this.lifeSpan = loader.lifeSpan;
    }
    CacheService.getInstance = function (loader, platformId, injector) {
        return CacheService.instance;
    };
    CacheService.normalizeKey = function (key) {
        if (CacheService.validateKey(key))
            throw new Error('Please provide a valid key to save in the CacheService');
        return "" + key;
    };
    CacheService.validateKey = function (key) {
        return !key
            || typeof key === 'boolean'
            || Number.isNaN(key);
    };
    CacheService.validateValue = function (value) {
        return value.lifeSpan.expiry && value.lifeSpan.expiry > Date.now();
    };
    Object.defineProperty(CacheService.prototype, "key", {
        get: function () {
            return this.loader.key;
        },
        enumerable: true,
        configurable: true
    });
    CacheService.prototype.has = function (key) {
        key = CacheService.normalizeKey(key);
        return this.cache.keys.indexOf(key) !== -1;
    };
    CacheService.prototype.set = function (key, value, returnType, lifeSpan) {
        if (returnType === void 0) { returnType = ReturnType.Scalar; }
        key = CacheService.normalizeKey(key);
        lifeSpan = lifeSpan || this.lifeSpan;
        return this.cache.setItem(key, {
            data: value,
            returnType: returnType,
            lifeSpan: this.parseLifeSpan(lifeSpan)
        });
    };
    CacheService.prototype.get = function (key) {
        key = CacheService.normalizeKey(key);
        var cached = this.cache.getItem(key);
        var res;
        if (cached)
            if (CacheService.validateValue(cached))
                res = cached.data;
            else
                this.remove(key);
        return res;
    };
    CacheService.prototype.getWithMetadata = function (key) {
        key = CacheService.normalizeKey(key);
        var cached = this.cache.getItem(key);
        var res;
        if (cached)
            if (CacheService.validateValue(cached))
                res = cached;
            else
                this.remove(key);
        return res;
    };
    CacheService.prototype.remove = function (key, wild) {
        if (wild === void 0) { wild = false; }
        key = CacheService.normalizeKey(key);
        this.cache.removeItem(key, wild);
    };
    CacheService.prototype.clear = function () {
        this.cache.clear();
    };
    CacheService.prototype.dehydrate = function () {
        var _this = this;
        var keys = this.cache.keys || [];
        var res = {};
        keys.forEach(function (key) {
            res[key] = _this.cache.getItem(key);
        });
        return res;
    };
    CacheService.prototype.rehydrate = function (json) {
        var _this = this;
        Object.keys(json)
            .forEach(function (key) {
            key = CacheService.normalizeKey(key);
            _this.cache.setItem(key, json[key]);
        });
    };
    CacheService.prototype.parseLifeSpan = function (lifeSpan) {
        return {
            expiry: lifeSpan.expiry || (lifeSpan.TTL ? Date.now() + (lifeSpan.TTL * 1000) : this.lifeSpan.expiry),
            TTL: lifeSpan.TTL || this.lifeSpan.TTL
        };
    };
    CacheService.instance = undefined;
    CacheService.decorators = [
        { type: Injectable },
    ];
    CacheService.ctorParameters = function () { return [
        { type: CacheLoader },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: Injector }
    ]; };
    return CacheService;
}());

var Cache = (function () {
    function Cache() {
    }
    return Cache;
}());

function isPromise(obj) {
    return !!obj && typeof obj.then === 'function';
}
function isObservable(obj) {
    return !!obj && typeof obj.subscribe === 'function';
}

function CacheKey(target, propertyKey, index) {
    var metadataKey = "__cache_" + propertyKey + "_keys";
    Array.isArray(target[metadataKey])
        ? target[metadataKey].push(index)
        : target[metadataKey] = [index];
}
function Cached(key) {
    return function (target, propertyKey, descriptor) {
        var method = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var cache = CacheService.getInstance();
            var metadataKey = "__cache_" + propertyKey + "_keys";
            var indices = target[metadataKey];
            var keyParts = '';
            if (Array.isArray(indices))
                for (var i = 0; i < args.length; i++)
                    if (indices.indexOf(i) !== -1)
                        keyParts = !keyParts
                            ? String(args[i])
                            : keyParts + "_" + String(args[i]);
            var cacheKey = !keyParts
                ? key
                : key + "_" + keyParts;
            cacheKey = CacheService.normalizeKey(cacheKey);
            if (!cacheKey || !cache)
                return method.apply(this, args);
            if (cache.has(cacheKey)) {
                var cached = cache.getWithMetadata(cacheKey);
                if (cached && cached.data)
                    switch (cached.returnType) {
                        case ReturnType.Observable:
                            return of(cached.data);
                        case ReturnType.Promise:
                            return Promise.resolve(cached.data);
                        default:
                            return cached.data;
                    }
            }
            var value = method.apply(this, args);
            if (isObservable(value))
                return value
                    .pipe(map(function (res) {
                    cache.set(cacheKey, res, ReturnType.Observable);
                    return res;
                }));
            else if (isPromise(value))
                return value.then(function (res) {
                    cache.set(cacheKey, res, ReturnType.Promise);
                    return res;
                });
            cache.set(cacheKey, value);
            return value;
        };
        return descriptor;
    };
}

var Storage = (function (_super) {
    __extends(Storage, _super);
    function Storage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Storage;
}(EventEmitter));

var STORAGE = new InjectionToken('STORAGE');
function cacheFactory() {
    return new CacheStaticLoader();
}
function cacheServiceFactory(loader, platformId, injector) {
    return new CacheService(loader, platformId, injector);
}
var CacheModule = (function () {
    function CacheModule(parentModule) {
        if (parentModule)
            throw new Error('CacheModule already loaded; import in root module only.');
    }
    CacheModule.forRoot = function (configuredProvider) {
        if (configuredProvider === void 0) { configuredProvider = {
            provide: CacheLoader,
            useFactory: (cacheFactory)
        }; }
        return {
            ngModule: CacheModule,
            providers: [
                configuredProvider,
                {
                    provide: CacheService,
                    useFactory: (cacheServiceFactory),
                    deps: [
                        CacheLoader,
                        PLATFORM_ID,
                        Injector
                    ]
                }
            ]
        };
    };
    CacheModule.decorators = [
        { type: NgModule },
    ];
    CacheModule.ctorParameters = function () { return [
        { type: CacheModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    return CacheModule;
}());

export { STORAGE, cacheFactory, cacheServiceFactory, CacheModule, Cache, CacheLoader, CacheStaticLoader, CACHE, CacheService, CacheKey, Cached, Storage };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNhY2hlLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BuZ3gtY2FjaGUvY29yZS9zcmMvY2FjaGUubG9hZGVyLnRzIiwibmc6Ly9Abmd4LWNhY2hlL2NvcmUvc3JjL21vZGVscy9yZXR1cm4tdHlwZS50cyIsIm5nOi8vQG5neC1jYWNoZS9jb3JlL3NyYy9jYWNoZS5zZXJ2aWNlLnRzIiwibmc6Ly9Abmd4LWNhY2hlL2NvcmUvc3JjL2NhY2hlLnRzIiwibmc6Ly9Abmd4LWNhY2hlL2NvcmUvc3JjL3V0aWwudHMiLCJuZzovL0BuZ3gtY2FjaGUvY29yZS9zcmMvY2FjaGVkLmRlY29yYXRvci50cyIsIm5nOi8vQG5neC1jYWNoZS9jb3JlL3NyYy9zdG9yYWdlLnRzIiwibmc6Ly9Abmd4LWNhY2hlL2NvcmUvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kdWxlXHJcbmltcG9ydCB7IENhY2hlU2V0dGluZ3MgfSBmcm9tICcuL21vZGVscy9jYWNoZS1zZXR0aW5ncyc7XHJcbmltcG9ydCB7IExpZmVTcGFuIH0gZnJvbSAnLi9tb2RlbHMvbGlmZS1zcGFuJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYWNoZUxvYWRlciB7XHJcbiAgYWJzdHJhY3QgZ2V0IGtleSgpOiBzdHJpbmc7XHJcblxyXG4gIGFic3RyYWN0IGdldCBsaWZlU3BhbigpOiBMaWZlU3BhbjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENhY2hlU3RhdGljTG9hZGVyIGltcGxlbWVudHMgQ2FjaGVMb2FkZXIge1xyXG4gIGdldCBrZXkoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkU2V0dGluZ3Mua2V5O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxpZmVTcGFuKCk6IExpZmVTcGFuIHtcclxuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkU2V0dGluZ3MubGlmZVNwYW47XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3ZpZGVkU2V0dGluZ3M6IENhY2hlU2V0dGluZ3MgPSB7XHJcbiAgICBrZXk6ICdOR1hfQ0FDSEUnLFxyXG4gICAgbGlmZVNwYW46IHtcclxuICAgICAgZXhwaXJ5OiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICBUVEw6IE51bWJlci5NQVhfVkFMVUVcclxuICAgIH1cclxuICB9KSB7XHJcbiAgfVxyXG59XHJcbiIsImV4cG9ydCBlbnVtIFJldHVyblR5cGUge1xyXG4gIC8qKlxyXG4gICAqIHNjYWxhclxyXG4gICAqL1xyXG4gIFNjYWxhciA9IDAsXHJcbiAgLyoqXHJcbiAgICogb2JzZXJ2YWJsZVxyXG4gICAqL1xyXG4gIE9ic2VydmFibGUgPSAxMCxcclxuICAvKipcclxuICAgKiBwcm9taXNlXHJcbiAgICovXHJcbiAgUHJvbWlzZSA9IDIwXHJcbn1cclxuIiwiLy8gYW5ndWxhclxyXG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8vIG1vZHVsZVxyXG5pbXBvcnQgeyBMaWZlU3BhbiB9IGZyb20gJy4vbW9kZWxzL2xpZmUtc3Bhbic7XHJcbmltcG9ydCB7IENhY2hlVmFsdWUgfSBmcm9tICcuL21vZGVscy9jYWNoZS12YWx1ZSc7XHJcbmltcG9ydCB7IFJldHVyblR5cGUgfSBmcm9tICcuL21vZGVscy9yZXR1cm4tdHlwZSc7XHJcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9jYWNoZSc7XHJcbmltcG9ydCB7IENhY2hlTG9hZGVyIH0gZnJvbSAnLi9jYWNoZS5sb2FkZXInO1xyXG5cclxuZXhwb3J0IGNvbnN0IENBQ0hFID0gbmV3IEluamVjdGlvblRva2VuPENhY2hlPignQ0FDSEUnKTtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIENhY2hlU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IENhY2hlU2VydmljZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGNhY2hlOiBDYWNoZTtcclxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgbGlmZVNwYW46IExpZmVTcGFuO1xyXG5cclxuICBzdGF0aWMgZ2V0SW5zdGFuY2UobG9hZGVyPzogQ2FjaGVMb2FkZXIsIHBsYXRmb3JtSWQ/OiBhbnksIGluamVjdG9yPzogSW5qZWN0b3IpOiBDYWNoZVNlcnZpY2Uge1xyXG4gICAgcmV0dXJuIENhY2hlU2VydmljZS5pbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBub3JtYWxpemVLZXkoa2V5OiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgaWYgKENhY2hlU2VydmljZS52YWxpZGF0ZUtleShrZXkpKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgdmFsaWQga2V5IHRvIHNhdmUgaW4gdGhlIENhY2hlU2VydmljZScpO1xyXG5cclxuICAgIHJldHVybiBgJHtrZXl9YDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIHZhbGlkYXRlS2V5KGtleTogc3RyaW5nIHwgbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gIWtleVxyXG4gICAgICB8fCB0eXBlb2Yga2V5ID09PSAnYm9vbGVhbidcclxuICAgICAgfHwgTnVtYmVyLmlzTmFOKGtleSBhcyBudW1iZXIpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRhdGVWYWx1ZSh2YWx1ZTogQ2FjaGVWYWx1ZSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHZhbHVlLmxpZmVTcGFuLmV4cGlyeSAmJiB2YWx1ZS5saWZlU3Bhbi5leHBpcnkgPiBEYXRlLm5vdygpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbG9hZGVyOiBDYWNoZUxvYWRlcixcclxuICAgICAgICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHJlYWRvbmx5IHBsYXRmb3JtSWQ6IGFueSxcclxuICAgICAgICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGluamVjdG9yOiBJbmplY3Rvcikge1xyXG4gICAgQ2FjaGVTZXJ2aWNlLmluc3RhbmNlID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5pbmplY3Rvci5nZXQoQ0FDSEUpO1xyXG4gICAgdGhpcy5saWZlU3BhbiA9IGxvYWRlci5saWZlU3BhbjtcclxuICB9XHJcblxyXG4gIGdldCBrZXkoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLmxvYWRlci5rZXk7XHJcbiAgfVxyXG5cclxuICBoYXMoa2V5OiBzdHJpbmcgfCBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIGtleSA9IENhY2hlU2VydmljZS5ub3JtYWxpemVLZXkoa2V5KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5rZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XHJcbiAgfVxyXG5cclxuICBzZXQoa2V5OiBzdHJpbmcgfCBudW1iZXIsIHZhbHVlOiBhbnksIHJldHVyblR5cGU6IFJldHVyblR5cGUgPSBSZXR1cm5UeXBlLlNjYWxhciwgbGlmZVNwYW4/OiBMaWZlU3Bhbik6IGJvb2xlYW4ge1xyXG4gICAga2V5ID0gQ2FjaGVTZXJ2aWNlLm5vcm1hbGl6ZUtleShrZXkpO1xyXG4gICAgbGlmZVNwYW4gPSBsaWZlU3BhbiB8fCB0aGlzLmxpZmVTcGFuO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmNhY2hlLnNldEl0ZW0oa2V5LCB7XHJcbiAgICAgIGRhdGE6IHZhbHVlLFxyXG4gICAgICByZXR1cm5UeXBlLFxyXG4gICAgICBsaWZlU3BhbjogdGhpcy5wYXJzZUxpZmVTcGFuKGxpZmVTcGFuKVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5OiBzdHJpbmcgfCBudW1iZXIpOiBhbnkge1xyXG4gICAga2V5ID0gQ2FjaGVTZXJ2aWNlLm5vcm1hbGl6ZUtleShrZXkpO1xyXG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5jYWNoZS5nZXRJdGVtKGtleSk7XHJcbiAgICBsZXQgcmVzO1xyXG5cclxuICAgIGlmIChjYWNoZWQpXHJcbiAgICAgIGlmIChDYWNoZVNlcnZpY2UudmFsaWRhdGVWYWx1ZShjYWNoZWQpKVxyXG4gICAgICAgIHJlcyA9IGNhY2hlZC5kYXRhO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuXHJcbiAgZ2V0V2l0aE1ldGFkYXRhKGtleTogc3RyaW5nIHwgbnVtYmVyKTogQ2FjaGVWYWx1ZSB7XHJcbiAgICBrZXkgPSBDYWNoZVNlcnZpY2Uubm9ybWFsaXplS2V5KGtleSk7XHJcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmNhY2hlLmdldEl0ZW0oa2V5KTtcclxuICAgIGxldCByZXM7XHJcblxyXG4gICAgaWYgKGNhY2hlZClcclxuICAgICAgaWYgKENhY2hlU2VydmljZS52YWxpZGF0ZVZhbHVlKGNhY2hlZCkpXHJcbiAgICAgICAgcmVzID0gY2FjaGVkO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5yZW1vdmUoa2V5KTtcclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlKGtleTogc3RyaW5nIHwgbnVtYmVyLCB3aWxkID0gZmFsc2UpOiB2b2lkIHtcclxuICAgIGtleSA9IENhY2hlU2VydmljZS5ub3JtYWxpemVLZXkoa2V5KTtcclxuXHJcbiAgICB0aGlzLmNhY2hlLnJlbW92ZUl0ZW0oa2V5LCB3aWxkKTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xyXG4gIH1cclxuXHJcbiAgZGVoeWRyYXRlKCk6IGFueSB7XHJcbiAgICBjb25zdCBrZXlzID0gdGhpcy5jYWNoZS5rZXlzIHx8IFtdO1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcblxyXG4gICAga2V5cy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICByZXNba2V5XSA9IHRoaXMuY2FjaGUuZ2V0SXRlbShrZXkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIHJlaHlkcmF0ZShqc29uOiBhbnkpOiB2b2lkIHtcclxuICAgIE9iamVjdC5rZXlzKGpzb24pXHJcbiAgICAgIC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGtleSA9IENhY2hlU2VydmljZS5ub3JtYWxpemVLZXkoa2V5KTtcclxuICAgICAgICB0aGlzLmNhY2hlLnNldEl0ZW0oa2V5LCBqc29uW2tleV0pO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFyc2VMaWZlU3BhbihsaWZlU3BhbjogTGlmZVNwYW4pOiBMaWZlU3BhbiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBleHBpcnk6IGxpZmVTcGFuLmV4cGlyeSB8fCAobGlmZVNwYW4uVFRMID8gRGF0ZS5ub3coKSArIChsaWZlU3Bhbi5UVEwgKiAxMDAwKSA6IHRoaXMubGlmZVNwYW4uZXhwaXJ5KSxcclxuICAgICAgVFRMOiBsaWZlU3Bhbi5UVEwgfHwgdGhpcy5saWZlU3Bhbi5UVExcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsIi8vIG1vZHVsZVxyXG5pbXBvcnQgeyBDYWNoZVZhbHVlIH0gZnJvbSAnLi9tb2RlbHMvY2FjaGUtdmFsdWUnO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENhY2hlIHtcclxuICBhYnN0cmFjdCBnZXQga2V5cygpOiBBcnJheTxzdHJpbmc+O1xyXG5cclxuICBhYnN0cmFjdCBnZXRJdGVtKGtleTogc3RyaW5nKTogQ2FjaGVWYWx1ZTtcclxuXHJcbiAgYWJzdHJhY3Qgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IENhY2hlVmFsdWUpOiBib29sZWFuO1xyXG5cclxuICBhYnN0cmFjdCByZW1vdmVJdGVtKGtleTogc3RyaW5nLCB3aWxkOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgYWJzdHJhY3QgY2xlYXIoKTogdm9pZDtcclxufVxyXG4iLCIvLyBsaWJzXHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuLy8gVE9ETyB1c2UgU3ltYm9sLm9ic2VydmFibGUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RpdmVYL3J4anMvaXNzdWVzLzI0MTUgd2lsbCBiZSByZXNvbHZlZFxyXG4vLyBpbXBvcnQgeyAkJG9ic2VydmFibGUgYXMgc3ltYm9sT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvc3ltYm9sL29ic2VydmFibGUnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZShvYmo6IGFueSk6IG9iaiBpcyBQcm9taXNlPGFueT4ge1xyXG4gIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09ic2VydmFibGUob2JqOiBhbnkgfCBPYnNlcnZhYmxlPGFueT4pOiBvYmogaXMgT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAvLyBUT0RPIHVzZSBTeW1ib2wub2JzZXJ2YWJsZSB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdGl2ZVgvcnhqcy9pc3N1ZXMvMjQxNSB3aWxsIGJlIHJlc29sdmVkXHJcbiAgLy8gcmV0dXJuICEhKG9iaiAmJiBvYmpbc3ltYm9sT2JzZXJ2YWJsZV0pO1xyXG4gIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqLnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4iLCIvLyBsaWJzXHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG4vLyBtb2R1bGVcclxuaW1wb3J0IHsgUmV0dXJuVHlwZSB9IGZyb20gJy4vbW9kZWxzL3JldHVybi10eXBlJztcclxuaW1wb3J0IHsgQ2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9jYWNoZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBpc1Byb21pc2UgfSBmcm9tICcuL3V0aWwnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENhY2hlS2V5KHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcbiAgY29uc3QgbWV0YWRhdGFLZXkgPSBgX19jYWNoZV8ke3Byb3BlcnR5S2V5fV9rZXlzYDtcclxuXHJcbiAgQXJyYXkuaXNBcnJheSh0YXJnZXRbbWV0YWRhdGFLZXldKVxyXG4gICAgPyB0YXJnZXRbbWV0YWRhdGFLZXldLnB1c2goaW5kZXgpXHJcbiAgICA6IHRhcmdldFttZXRhZGF0YUtleV0gPSBbaW5kZXhdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2FjaGVkKGtleTogc3RyaW5nKTogYW55IHwgT2JzZXJ2YWJsZTxhbnk+IHwgUHJvbWlzZTxhbnk+IHtcclxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogRnVuY3Rpb24sIHByb3BlcnR5S2V5OiBzdHJpbmcsIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPGFueT4pOiBhbnkgfCBPYnNlcnZhYmxlPGFueT4gfCBQcm9taXNlPGFueT4ge1xyXG4gICAgY29uc3QgbWV0aG9kOiBGdW5jdGlvbiA9IGRlc2NyaXB0b3IudmFsdWU7XHJcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oLi4uYXJnczogQXJyYXk8YW55Pik6IGFueSB8IE9ic2VydmFibGU8YW55PiB8IFByb21pc2U8YW55PiB7XHJcbiAgICAgIGNvbnN0IGNhY2hlID0gQ2FjaGVTZXJ2aWNlLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICBjb25zdCBtZXRhZGF0YUtleSA9IGBfX2NhY2hlXyR7cHJvcGVydHlLZXl9X2tleXNgO1xyXG4gICAgICBjb25zdCBpbmRpY2VzID0gdGFyZ2V0W21ldGFkYXRhS2V5XTtcclxuXHJcbiAgICAgIGxldCBrZXlQYXJ0cyA9ICcnO1xyXG5cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kaWNlcykpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgaWYgKGluZGljZXMuaW5kZXhPZihpKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIGtleVBhcnRzID0gIWtleVBhcnRzXHJcbiAgICAgICAgICAgICAgPyBTdHJpbmcoYXJnc1tpXSlcclxuICAgICAgICAgICAgICA6IGAke2tleVBhcnRzfV8ke1N0cmluZyhhcmdzW2ldKX1gO1xyXG5cclxuICAgICAgbGV0IGNhY2hlS2V5ID0gIWtleVBhcnRzXHJcbiAgICAgICAgPyBrZXlcclxuICAgICAgICA6IGAke2tleX1fJHtrZXlQYXJ0c31gO1xyXG5cclxuICAgICAgY2FjaGVLZXkgPSBDYWNoZVNlcnZpY2Uubm9ybWFsaXplS2V5KGNhY2hlS2V5KTtcclxuXHJcbiAgICAgIGlmICghY2FjaGVLZXkgfHwgIWNhY2hlKVxyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cclxuICAgICAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcclxuICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXRXaXRoTWV0YWRhdGEoY2FjaGVLZXkpO1xyXG5cclxuICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5kYXRhKVxyXG4gICAgICAgICAgc3dpdGNoIChjYWNoZWQucmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFJldHVyblR5cGUuT2JzZXJ2YWJsZTpcclxuICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKGNhY2hlZC5kYXRhKTtcclxuICAgICAgICAgICAgY2FzZSBSZXR1cm5UeXBlLlByb21pc2U6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWQuZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZC5kYXRhO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgY29uc3QgdmFsdWUgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XHJcblxyXG4gICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gdmFsdWVcclxuICAgICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKHJlczogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCByZXMsIFJldHVyblR5cGUuT2JzZXJ2YWJsZSk7XHJcblxyXG4gICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gKHZhbHVlIGFzIGFueSkudGhlbigocmVzOiBhbnkpID0+IHtcclxuICAgICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgcmVzLCBSZXR1cm5UeXBlLlByb21pc2UpO1xyXG5cclxuICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHZhbHVlKTtcclxuXHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XHJcbiAgfTtcclxufVxyXG4iLCIvLyBsaWJzXHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RvcmFnZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgYWJzdHJhY3QgbGVuZ3RoOiBudW1iZXI7XHJcbiAgYWJzdHJhY3Qga2V5czogQXJyYXk8c3RyaW5nPjtcclxuXHJcbiAgYWJzdHJhY3Qgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IGJvb2xlYW47XHJcblxyXG4gIGFic3RyYWN0IGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBhbnk7XHJcblxyXG4gIGFic3RyYWN0IHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiBib29sZWFuO1xyXG5cclxuICBhYnN0cmFjdCBrZXkoaW5kZXg6IG51bWJlcik6IHN0cmluZztcclxuXHJcbiAgYWJzdHJhY3QgY2xlYXIoKTogYm9vbGVhbjtcclxufVxyXG4iLCIvLyBhbmd1bGFyXHJcbmltcG9ydCB7XHJcbiAgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSwgT3B0aW9uYWwsIFBMQVRGT1JNX0lELCBTa2lwU2VsZlxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuLy8gbW9kdWxlXHJcbmltcG9ydCB7IENhY2hlTG9hZGVyLCBDYWNoZVN0YXRpY0xvYWRlciB9IGZyb20gJy4vc3JjL2NhY2hlLmxvYWRlcic7XHJcbmltcG9ydCB7IENhY2hlU2VydmljZSB9IGZyb20gJy4vc3JjL2NhY2hlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnLi9zcmMvc3RvcmFnZSc7XHJcblxyXG5leHBvcnQgKiBmcm9tICcuL3NyYy9tb2RlbHMvY2FjaGUtc2V0dGluZ3MnO1xyXG5leHBvcnQgKiBmcm9tICcuL3NyYy9tb2RlbHMvY2FjaGUtdmFsdWUnO1xyXG5leHBvcnQgKiBmcm9tICcuL3NyYy9tb2RlbHMvbGlmZS1zcGFuJztcclxuZXhwb3J0ICogZnJvbSAnLi9zcmMvY2FjaGUnO1xyXG5leHBvcnQgKiBmcm9tICcuL3NyYy9jYWNoZS5sb2FkZXInO1xyXG5leHBvcnQgKiBmcm9tICcuL3NyYy9jYWNoZS5zZXJ2aWNlJztcclxuZXhwb3J0ICogZnJvbSAnLi9zcmMvY2FjaGVkLmRlY29yYXRvcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3N0b3JhZ2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNUT1JBR0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48U3RvcmFnZT4oJ1NUT1JBR0UnKTtcclxuXHJcbi8vIGZvciBBb1QgY29tcGlsYXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlRmFjdG9yeSgpOiBDYWNoZUxvYWRlciB7XHJcbiAgcmV0dXJuIG5ldyBDYWNoZVN0YXRpY0xvYWRlcigpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FjaGVTZXJ2aWNlRmFjdG9yeShsb2FkZXI6IENhY2hlTG9hZGVyLCBwbGF0Zm9ybUlkOiBhbnksIGluamVjdG9yOiBJbmplY3Rvcik6IENhY2hlU2VydmljZSB7XHJcbiAgcmV0dXJuIG5ldyBDYWNoZVNlcnZpY2UobG9hZGVyLCBwbGF0Zm9ybUlkLCBpbmplY3Rvcik7XHJcbn1cclxuXHJcbkBOZ01vZHVsZSgpXHJcbmV4cG9ydCBjbGFzcyBDYWNoZU1vZHVsZSB7XHJcbiAgc3RhdGljIGZvclJvb3QoY29uZmlndXJlZFByb3ZpZGVyOiBhbnkgPSB7XHJcbiAgICBwcm92aWRlOiBDYWNoZUxvYWRlcixcclxuICAgIHVzZUZhY3Rvcnk6IChjYWNoZUZhY3RvcnkpXHJcbiAgfSk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IENhY2hlTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBjb25maWd1cmVkUHJvdmlkZXIsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogQ2FjaGVTZXJ2aWNlLFxyXG4gICAgICAgICAgdXNlRmFjdG9yeTogKGNhY2hlU2VydmljZUZhY3RvcnkpLFxyXG4gICAgICAgICAgZGVwczogW1xyXG4gICAgICAgICAgICBDYWNoZUxvYWRlcixcclxuICAgICAgICAgICAgUExBVEZPUk1fSUQsXHJcbiAgICAgICAgICAgIEluamVjdG9yXHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQFNraXBTZWxmKCkgcGFyZW50TW9kdWxlOiBDYWNoZU1vZHVsZSkge1xyXG4gICAgaWYgKHBhcmVudE1vZHVsZSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZU1vZHVsZSBhbHJlYWR5IGxvYWRlZDsgaW1wb3J0IGluIHJvb3QgbW9kdWxlIG9ubHkuJyk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJvYnNlcnZhYmxlT2YiLCJ0c2xpYl8xLl9fZXh0ZW5kcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztJQUlBO0tBSUM7SUFBRCxrQkFBQztDQUFBLElBQUE7O0lBV0MsMkJBQTZCLGdCQU01QjtRQU40QixpQ0FBQSxFQUFBO1lBQzNCLEdBQUcsRUFBRSxXQUFXO1lBQ2hCLFFBQVEsRUFBRTtnQkFDUixNQUFNLEVBQUUsTUFBTSxDQUFDLFNBQVM7Z0JBQ3hCLEdBQUcsRUFBRSxNQUFNLENBQUMsU0FBUzthQUN0QjtTQUNGO1FBTjRCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FNNUM7S0FDQTtJQWZELHNCQUFJLGtDQUFHO2FBQVA7WUFDRSxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUM7U0FDbEM7OztPQUFBO0lBRUQsc0JBQUksdUNBQVE7YUFBWjtZQUNFLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQztTQUN2Qzs7O09BQUE7SUFVSCx3QkFBQztDQUFBOztBQzNCRCxJQUFZLFVBYVg7QUFiRCxXQUFZLFVBQVU7SUFJcEIsK0NBQVUsQ0FBQTtJQUlWLHdEQUFlLENBQUE7SUFJZixrREFBWSxDQUFBO0NBQ2IsRUFiVyxVQUFVLEtBQVYsVUFBVSxRQWFyQjs7SUNIWSxLQUFLLEdBQUcsSUFBSSxj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